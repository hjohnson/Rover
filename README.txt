Introduction:
      This time, I'm presenting a whole robot, a project that has a slightly larger scale than my normal ones. This robot (or rover) was designed as an educational tool, a project to be built by teams of High School students over a period of 2-3 weeks.  As such, the robot was designed for simplicity and durability, not low price. The robot’s design is split into several modules: Mechanical Frame, Locomotion, Sensors, and Control. 

Mechanical Frame: 
	Material: The frame is constructed from four 1” width 80/20 extruded aluminum rails. For those who don’t know, the 80/20 T-slot system is called “the industrial erector set,” and the description is fitting. The rails can be cut to size relatively easily with hand tools (though we use power tools,) and can be bolted together using aluminum plates, “T-nuts” and screws, instead of welding. This means that the system is easily reconfigurable on the fly, and small mistakes can be quickly remedied by loosening the plates and shifting the rail, instead of by removing welds.  
	Design: The main frame is a simple rectangle constructed from four lengths of 80/20 rail, bolted together at the corners with four triangular plates.  Attached to this main frame are several other lengths of rail. One houses the bumper; another houses the ball transport and vulnerability switch. (All of which will be discussed later) Three vertical stalks are also integrated into the design to hold other sensors. As a side bonus, these stalks are mounted firmly enough that the robot can technically be flipped upside down and rest on them, for easier service.

Locomotion:
	Mechanical Drive System: The robot incorporates two pneumatic wheels with integrated sprockets. The two wheels can rotate independently of each other, enabling steering, and are attached to a single axle, which is a 1/2-inch outside diameter tube. This axle is attached to the underside of the frame using pillow blocks.  Two 8-amp stepper motors drive the 2 wheels through a chain system. Sprockets attach to the motors’ drive shafts, and connect to the wheel-mounted sprockets through lengths of chain.  
	Motor Control System: A pair of Anaheim Automation MBC10101 Stepper Motor Drivers control the stepper motors. These drivers are powered by 24V provided by the robot’s power unit, and have control inputs driven by the main control card. The main controls are: clock input, to determine the speed of the motors; Inhibit, to remove power from the motors and stop the robot; and Direction, to control the direction of rotation. These inputs are controlled by the main board, which will be discussed later. These drivers, while expensive, are from my experience highly reliable and are hard to burn, an excellent feature when wired by inexperienced builders who can easily miss a ground or clock signal. 
	Electrical Supply (power unit): The robot’s power is provided by a custom supply based around two 12V, 2200mAh, Lead-Acid rechargeable batteries. When in Charge mode, the power supply wires these two batteries in parallel, each with their own 10 ohm ceramic power resistor, to the main power jack. While in this mode, ~14V can be supplied from an external regulated supply to charge the batteries. When in Drive mode, the power supply switches the two batteries into series, providing 24V output to the main power jack, which runs to the stepper motor drivers. The power supply also taps one of the batteries to supply 12V to a 7805 5V voltage regulator, which powers the control circuitry. Due to the power dissipation through this 7805, it is screwed to a “heat sink” (bottle cap). 

Sensors:
	The robot integrates several sensors to react to its surroundings. These include front-mounted bumper switches and phototransistors, and a rear-mounted vulnerability switch. 
	Bumper: A flexible bumper is attached to the front of the robot, along with 2 momentary lever switches. This enables the robot to detect when it has run into an object, usually the wall. The robot’s response to this information can be determined in software by the students.
	Vulnerability Switch: A 3 position (SPTT) toggle switch is mounted to the rear of the robot, and acts as a manual shutdown switch and “weak spot.” When the switch is positioned in the center (not connected), the robot operates normally. However, when the switch is actuated to either side, the robot instantly shuts down, turning off the motors and rendering the robot inoperable. This feature is implemented in software, but tampering with that section of code is forbidden. This switch is primarily used as a safety feature, but is also exploited for the high school competition, as bonus points are awarded to teams who can activate their opponents’ switches. 
	Phototransistors: While these are not currently attached, the phototransistors can be used to detect light levels, allowing the robots to navigate based on guidance from a flashlight, as well as to seek out the beacons above the competition’s “goals.” 

Control:
	At last, the more recognizable part. The robot’s control system is remarkably simple, consisting of an Arduino-based card and an associated remote control.
	Control Card Hardware: 
      The actual circuitry on the card is remarkably simple, and primarily consists of an Arduino microprocessor, an XBee wireless transceiver, and some support circuitry.
       Motor Control: The Arduino output pins are buffered through 74LS14 hex inverters and then sent to the stepper motor drivers and the inputs from the bumper and vulnerability switches. The outputs are pulled up through resistors to 5V to ensure that the drivers are properly driven, as we had previously encountered problems where the Arduino’s output pins couldn’t sufficiently drive the motor drivers’ input pins. 
      Sensors: The sensor inputs are buffered as well to form an extremely simple debouncing circuit. The Phototransistors also run through 1.5K resistors to ground, forming common collector amplifiers whose outputs run into the Analog In pins on the Arduino. 
      XBee: The control card utilizes an XBee wireless transceiver to enable bidirectional serial communication between the robot and the remote control. An Adafruit XBee Adapter kit is used to house the XBee and convert the Arduino’s 5V logic to the XBee’s 3.3V logic.  
	Control Card Software: 
      Motor Control: The top of the Card’s priority list is controlling the motor drivers. Each of these drivers takes 3 inputs (clock, inhibit, and direction) as discussed previously. The 2 clock lines are driven by independent square waves generated by the Arduino Tone library. These square waves typically have frequencies between 2KHz and 5KHz.  Because the stepper motors have 200 steps/rotation, these speeds translate to motor speeds between 10 and 25 motor revolutions per second. However, due to the gearing present through the sprockets, the robot’s wheels rotate at a lesser rate. (Embarrassingly, I haven’t actually counted sprocket teeth or done the rest of this math yet. I’ll get back to you.) Inhibit and Direction, the other 2 data lines (per driver) are comparatively simple. When the driver sees a logic low on the inhibit pin, the motor is turned on, and when the driver sees a logic high, the motors are turned off. Similarly, for direction, logic low results in forward rotation, logic high results in backwards rotation. 
      Vulnerability Switch: The vulnerability switch input is monitored using an interrupt, whose interrupt service routine disables both motors, then waits for the vulnerability switch to be returned to center before exiting. In this way, the motors are disabled upon the switch being flicked, and will not re-enable, no matter what the user says, until the switch is returned to center.
      XBee Remote Control: To communicate through the XBee, a simple serial protocol is used, along with a pre-determined command set. Incoming serial bytes are read and interpreted by the program, with, for example, “W” signifying forward movement, “S” signifying backward movement, and “F” signifying stop. For more information about this process, look at the previous article, about the Remote Control designed to interface with this system. 


